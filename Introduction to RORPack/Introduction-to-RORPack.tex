\documentclass[11pt, a4paper]{amsart}
\usepackage{amssymb, array, amsmath, amscd, pdfpages, enumerate, amsthm, setspace, mathtools}
\usepackage[papersize={17cm,26cm},total={12.7cm,22.5cm},left=2.15cm]{geometry}

\usepackage[utf8]{inputenc}
\usepackage{amssymb}
\usepackage{bm}
\usepackage{overpic}
%\usepackage{mathrsfs}
\usepackage{xcolor}
\usepackage{graphicx} 
\usepackage{ifthen}
\usepackage{listings}
%\lstset{language=Python}
\usepackage[colorlinks=true]{hyperref}
\usepackage{hyperref}


\newcommand{\COMMapproxRC}[1]{{\color{gray}#1}}
\renewcommand{\COMMapproxRC}[1]{}

\input{CustomCommandsCopy}
%\renewcommand{\Dom}{D}


\DeclareFixedFont{\ttb}{T1}{txtt}{bx}{n}{9} % for bold
\DeclareFixedFont{\ttm}{T1}{txtt}{m}{n}{9}  % for normal
\DeclareFixedFont{\itm}{T1}{txtt}{m}{it}{9}  % for normal

% Custom colors
\usepackage{color}
\definecolor{deepblue}{rgb}{0,0,0.5}
\definecolor{deepred}{rgb}{0.6,0,0}
\definecolor{deepgreen}{rgb}{0,0.5,0}
\lstset{
language=Python,
basicstyle=\ttm,
otherkeywords={self},             % Add keywords here
keywordstyle=\ttb\color{deepblue},
emph={MyClass,__init__},          % Custom highlighting
commentstyle=\itm,
emphstyle=\ttb\color{deepred},    % Custom highlighting style
stringstyle=\color{deepgreen},
frame=tb,                         % Any extra options here
showstringspaces=false            % 
}

\renewcommand{\Dom}{D}


\renewcommand{\pmat}[1]{\begin{bmatrix}#1\end{bmatrix}}
\renewcommand{\pmatsmall}[1]{\begin{bsmallmatrix}#1\end{bsmallmatrix}}


\newcommand{\CL}{C_\Lambda}
\newcommand{\CLt}{\tilde{C}_\Lambda}
\newcommand{\CeL}{C_{e\Lambda}}

\newcommand{\contr}[1]{Controller~\##1}



\newcommand{\XB}{X_B}
\newcommand{\XBBd}{X_{B,B_d}}
\newcommand{\ZG}{Z_{\Bc}}


\DeclareMathOperator{\blkdiag}{blockdiag}

\newcommand{\Hinfty}{H_\infty}

\newcommand{\Ac}{\mc{G}_1}
\newcommand{\Bc}{\mc{G}_2}
\newcommand{\Cc}{K}
\newcommand{\Ccone}{K}
\newcommand{\Cctwo}{K}
\newcommand{\Dc}{D_c}


\newcommand{\PARsysopspert}{(\tilde{A},\tilde{B},\tilde{B}_d,\tilde{C},\tilde{D})}
\newcommand{\PARsys}{(A,B,C,D)}
\newcommand{\PARsysS}{(A^S,B^S,C^S,D^S)}
%\newcommand{\PARsysfbops}{(A-B\Dc Q_1\CL, BQ_2\KL,Q_1C Q_1D)}
%\newcommand{\CLops}{(A_e,B_e,C_e,D_e)}

\newcommand{\PARcontr}{(\Ac,\Bc,\Cc,\Dc)}
\newcommand{\PARcontrone}{(\Ac,\Bc,\Cc,\Dcone)}


\newtheorem{theorem}{Theorem}[section]
%\newtheorem{prp}[thm]{Proposition}
\newtheorem{lemma}[theorem]{Lemma}
\newtheorem{proposition}[theorem]{Proposition}
\newtheorem{corollary}[theorem]{Corollary}
\theoremstyle{definition}
\newtheorem{definition}[theorem]{Definition}
\newtheorem{assumption}[theorem]{Assumption}
\newtheorem{remark}[theorem]{Remark}
\newtheorem{example}[theorem]{Example}

\numberwithin{equation}{section}


%\newtheorem*{ORPfb}{The Error Feedback Output Regulation Problem}
%\newtheorem*{RORP}{The Robust Output Regulation Problem}
\newenvironment{RORP}{\textbf{The Robust Output Regulation Problem.}\it}{}

\newcommand{\hfun}{h}

%\newcommand{\distref}{h_{\mbox{\scriptsize\textit{sig}}}}
%\newcommand{\distrefk}{\hat{h}_{\mbox{\scriptsize\textit{sig}}}(k)}
\newcommand{\distref}{w_{\mbox{\scriptsize\textit{ext}}}}
\newcommand{\distrefder}{\dot{w}_{\mbox{\scriptsize\textit{ext}}}}
\newcommand{\distrefk}{w^k_{\mbox{\scriptsize\textit{ext}}}}
%\newcommand{\distrefk}{\hat{w}_{\mbox{\scriptsize\textit{ext}}}(k)}

\newcommand{\yrefk}{y^k_{\mbox{\scriptsize\textit{ref}}}}
\newcommand{\wdistk}{w^k_{\mbox{\scriptsize\textit{dist}}}}
%\newcommand{\yrefk}{\hat{y}_{\mbox{\scriptsize\textit{ref}}}(k)}
%\newcommand{\wdistk}{\hat{w}_{\mbox{\scriptsize\textit{dist}}}(k)}
\newcommand{\wdisthat}{\hat{w}_{\mbox{\scriptsize\textit{dist}}}}


\newcommand{\yref}{y_{\mbox{\scriptsize\textit{ref}}}}
\newcommand{\wdist}{w_{\mbox{\scriptsize\textit{dist}}}}
\newcommand{\yrefpert}{\tilde{y}_{\mbox{\scriptsize\textit{ref}}}}
\newcommand{\wdistpert}{\tilde{w}_{\mbox{\scriptsize\textit{dist}}}}
\newcommand{\ydk}[1][k]{y_{d,#1}}


%\newcommand{\RORname}{RORPack}
\newcommand{\RORname}{\textbf{RORPack}}
\newcommand{\RORnameplain}{RORPack}


% Helpful macros



\newcommand{\shorten}[1]{{\color{gray}#1}}
\renewcommand{\shorten}[1]{}
%\newcommand{\shortencomm}[1]{{\color{purple}#1}}


\begin{document}


  \title[Introduction to ``\RORnameplain'']{Introduction to ``\RORname''\\[1ex]\footnotesize\mdseries{A Python software package for Robust Output Regulation}}
%\date{\today}
\thispagestyle{plain}

\author{Lassi Paunonen}
\address{Department of Mathematics, Tampere University, PO.\ Box 692, 33101 Tampere, Finland}
 \email{lassi.paunonen@tuni.fi}


\maketitle

\vspace{-3ex}

\begin{center}
  \today
\end{center}

\vspace{3ex}

{\small\tableofcontents}

\section{General Description}
%\label{sec:intro}

\RORname\ is a Python library
for controller design and simulation of robust output tracking and disturbance rejection for linear partial differential equation models. 
%Its main purpose is to give an  
The package contains a number of complete examples on robust controller design and simulation of PDE models
%. The types of models (at the moment) include
of the following types:
\begin{itemize}
  \item one-dimensional diffusion equations with either boundary or distributed control and observation.
  \item two-dimensional heat equation on a rectangular domain.
  \item one-dimensional wave equations with either distributed or boundary control and observation.
    \COMMapproxRC{
    \item two-dimensional wave equation on an annulus with boundary control and observation
    }
\end{itemize}
New examples will also be added in the future versions of the package.
%This collection of examples will also be expanded in the future.
%and a collection of examples on robust output tracking and disturbance rejection for distributed parameter systems.

The purpose of this document is to give a general introduction to the background theory of robust output regulation for linear PDE systems, to describe the mathematical models that are included as the example cases, and to document the usage of the software package on a general level.
 
The purpose of \RORname\ is to serve as a tool to \textit{illustrate} the theory of robust output regulation for distributed parameter systems and it should not (yet) be considered as a serious controller design software. 
The developers of the software do not take any responsibility and are not liable for any damage caused through use of this software.
In addition, at its present stage, the library is not optimized in terms of numerical accuracy. Any helpful comments on potential improvements of the numerical aspects will be greatly appreciated!

The \RORname\ software is distributed as open source under the GNU General Public License version 3 (see \texttt{LICENSE.txt} for detailed license and copyright information) and can freely downloaded at the address
\begin{center}
  \href{https://github.com/lassipau/rorpack/}{https://github.com/lassipau/rorpack/}
\end{center}
\shorten{
  This document is published in Arxiv (\href{http://arxiv.org/}{http://arxiv.org/}).
}
All comments and suggestions for improvements are welcome! These can be sent directly to \texttt{\href{mailto:lassi.paunonen@tuni.fi}{lassi.paunonen@tuni.fi}}.

\subsection{Controller design and simulation workflow}

Basic workflow for robust controller design and simulation for a given system is that the user creates a main file with the following parts:
\begin{enumerate}
%  \item Create a main file for the simulation. 
%    The file includes the following parts in the given order.
  \item Calling of user-defined Python routines that return a numerical approximation of the linear PDE model.
  \item Defining the reference and disturbance signals to be considered.
  \item Calling of a \RORname\ routine for construction of a robust controller that is suitable for the type of PDE model.
    This typically involves choosing appropriate parameters for the controller construction.
  \item Calling of \RORname\ routines for construction and simulation of the closed-loop system. The routines return numerical data describing the output, the error, the control signal, and the closed-loop state.
  \item Calling of \RORname\ routines for visualising the behaviour of the output and the output error, as well as 
    user-defined routines for illustrating the behaviour of the state of the controlled PDE system (multidimensional plots or animations).
\end{enumerate}
The example cases included in \RORname\ are built around main files that follow the same structure, and the users are encouraged to implement their own simulations by modifying the example codes.

It is also possible to combine other Python numerical software packages in the study of robust controller design for PDE models in order to employ ready-made numerical approximations or additional numerical methods in the computation of required controller parameters. This approach is illustrated in one of the PDE example cases ``\texttt{heat\_1d\_2}'' described in Section~\ref{sec:Heat1D2} (Case~2). 
In this example the transfer function of the controlled PDE and other parameters used in the controller construction are computed with the \textbf{Chebfun package}~\cite{DriHal14book,Tre13book} (\href{https://chebfun.org/}{https://chebfun.org/}) which provides flexible tools for solution of differential equations with extreme accuracy using spectral methods. 

\section{Introduction to Robust Output Regulation}

In this section we give a general introduction to the mathematical theory of \keyterm{robust output regulation}.
The purpose of the \RORname\ package is to illustrate controller design for linear distributed parameter systems of the form
\begin{subequations}
  \label{eq:plantintro}
  \eqn{
  \dot{x}(t)&=Ax(t)+Bu(t) + B_d\wdist(t), \qquad x(0)=x_0\in X\\
  y(t)&=\CL x(t)+Du(t) + D_d\wdist(t)
  } 
\end{subequations}
on a Banach or a Hilbert space $X$.
Controlled linear PDE models describing diffusion-convection phenomena, waves and vibrations and elastic deformations can be written in this form with a suitable differential operator~$A$~\cite{CurZwa95book,TucWei09book,JacZwa12book}. 
%generating a \keyterm{strongly continuous semigroup} on $X$.
In our main control problem the goal is to design a dynamic error feedback controller in such a way that the output $y(t)$ of the system converges to a given reference signal $\yref(t)$ despite the external disturbance signal $\wdist(t)$. In addition, the controller needs to be \keyterm{robust} in the sense that it achieves the output tracking and disturbance rejection even if the parameters $(A,B,B_d,C,D,D_d)$ are perturbed or contain small uncertainties.

Our main emphasis is on robust output regulation of linear partial differential equations, especially \keyterm{diffusion-convection equations}, \keyterm{wave equations}, and \keyterm{beam and plate equations}. However, the \RORname\ package can also be used for construction of controllers for  finite-dimensional systems with given matrices $(A,B,B_d,C,D,D_d)$. 

The full robust output regulation problem is defined in the following way. 

\medskip

\begin{RORP}
  Given a reference signal $\yref(t)$, design a dynamic error feedback controller such that the output $y(t)$ of the system converges to the reference signal asymptotically, i.e.,
  \eqn{
    \label{eq:errconv}
    \lim_{t\to \infty}\; \norm{y(t)-\yref(t)}_Y=0
  }
  despite the disturbance signal $\wdist(t)$.
  Moreover, the controller is required to
%  achieve closed-loop stability and to
be \keyterm{robust} in the sense that it achieves the convergence of the output~\eqref{eq:errconv} even under small uncertainties and changes in the parameters $(A,B,B_d,C,$ $D,D_d)$ of the system.
\end{RORP}

The reference signal $\yref(t)$ and the  disturbance signals $\wdist(t)$ are assumed to be of the form
\begin{subequations}
  \label{eq:yrefwdist}
  \eqn{
    \yref(t) &= a_0^1 + \sum_{k=1}^q (a_k^1 \cos(\gw_k t) + b_k^1 \sin(\gw_k t))\\
    \wdist(t) &= a_0^2 + \sum_{k=1}^q (a_k^2 \cos(\gw_k t) + b_k^2 \sin(\gw_k t))
  }
\end{subequations}
for some \textbf{known frequencies} $\set{\gw_k}_{k=0}^q\subset \R$ with $0=\gw_0<\gw_1<\ldots<\gw_q$ and unknown amplitudes $\set{a_k^j}_{k,j},\set{b_k^j}_{k,j}\subset \R$ (some of which may zero). 

Dynamic feedback is essential for achieving robust output regulation, and the control problem can indeed be solved with a dynamic error feedback controller (see Figure~\ref{fig:FBcontrol}). The classical \keyterm{internal model principle} gives a characterization for the controllers that solve the robust output regulation problem. This fundamental result was first introduced for finite-dimensional linear systems in the 1970's by Francis and Wonham~\cite{FraWon75a} and Davison~\cite{Dav76} (see~\citel{Hua04book}{Ch. 1} for an excellent overview).
The internal model principle was later extended for infinite-dimensional linear systems in by the Systems Theory Research Group at Tampere, Finland in the references~\cite{Imm06phd,PauPoh10,Pau11phd,PauPoh14a,Pau16a}\footnote{Our focus is on linear systems, but there is also an extensive literature on the internal model principle for nonlinear systems, see, e.g.,~\cite{Hua04book,ByrIsi03,ByrIsi04} and references therein.}.


\begin{figure}[h!]
  \begin{center}
    \includegraphics[width=.75\linewidth]{FB-control-scheme-horizontal-slim-notation} 
%    \begin{overpic}[width=\linewidth]{FB-control-scheme-horizontal-slim} 
%      \put(67,10.5){\mbox{System}}
%      \put(24.5,10.5){\mbox{Controller}}
%      \put(75,21){\mbox{\small$w_{\textit{\tiny dist}}(t)$}}
%      \put(50,14.5){\mbox{\small$u(t)$}}
%      \put(92,14.5){\mbox{\small$y(t)$}}
%      \put(11.5,14.5){\mbox{\small$e(t)$}}
%      \put(5.5,8){\mbox{\small$-$}}
%      \put(0,14.5){\mbox{\small$y_{\textit{\tiny ref}}(t)$}}
%    \end{overpic}
    \caption{Dynamic error feedback control scheme.}
    \label{fig:FBcontrol}
  \end{center}
\end{figure}

The internal model principle~\cite[Thm. 6.9]{PauPoh10} is also the most important tool in designing controllers for robust output regulation. The result states that a controller solves the robust output regulation problem if and only if the following conditions are satisfied.
\begin{itemize}
  \item The error feedback controller incorporates ``an internal model'' of
    the signals $\yref(t)$ and $\wdist(t)$ in~\eqref{eq:yrefwdist}.
  \item The closed-loop system is exponentially or strongly stable.
\end{itemize}
In controller design, the the internal model property can be guaranteed by choosing a suitable \keyterm{structure} for the controller. The rest of parameters are subsequently chosen in order to stabilize the closed-loop system.



The detailed description of the theory of robust output regulation problem and the internal model principle  can be found in the references listed below references. The main emphasis in the list is (shamelessly) on the publications by the Systems Theory Research Group at Tampere University, Finland.
\begin{itemize}
  \item \cite{Poh82,XuJer95,HamPoh96a,LogTow97,HamPoh00,RebWei03,LogTow03,ImmPoh06b,Imm07a,DosBas08,BouIdr09,HamPoh10,HamPoh11,PauPoh13a,XuSal14} (including PI-control for PDE models): Robust controller design in various forms for infinite-di\-men\-sional linear systems.
  \item \cite{PauPoh10} and~\cite{PauPoh14a}: The Internal Model Principle for infinite-dimensional linear systems with bounded and unbounded, respectively, input and output operators $B$ and $C$.
  \item \cite{Pau16a,Pau17b}: Robust controller design for \keyterm{regular linear systems}.
  \item \cite{HumPau18,HumKur18}: Robust controller design for \keyterm{port-Hamiltonian systems} and other boundary controlled partial differential equations.
  \item \cite{RebWei03,Pau17carxiv,PauLeGLHMNC18}: Robust controller design \keyterm{impedance passive systems}.
  \item \cite{PauPha18arxiv} for robust finite-dimensional low-order controller design for parabolic systems using Galerkin approximations and model reduction.
  \item References on the output regulation \keyterm{without} the robustness requirement:~\cite{Poh81a,Sch83b,ByrLau00,Deu11,NatGil14,XuDub17a}
\end{itemize}

The constructed controllers are of the form
\begin{subequations}
  \label{eq:controller}
  \eqn{
    \dot{z}(t)&=\mc{G}_1  z(t) + \mc{G}_2 (y(t)-\yref(t)),\qquad z(0)=z_0\in Z\\
    u(t) &= K z(t) +D_c (y(t)-\yref(t)).
  }
\end{subequations}
Here $y(t)-\yref(t)$ is the \keyterm{regulation error}.
The construction of the robust controllers are based on the references~\cite{Pau16a,Pau17carxiv} with certain modifications and improvements. In particular, the internal models are defined in their ``real forms'', making the controller real whenever the parameters of the plant are real. The same controllers also achieve robust output tracking also for reference and disturbance signals with complex coefficients $\set{a_k^j}_{k,j},\set{b_k^j}_{k,j}\subset \C$.

The constructions of the robust controllers use the knowledge of the frequencies $\set{\gw_k}_k $ of the reference and disturbance signals, the number of outputs $p:=\dim Y$ of the system~\eqref{eq:plantintro}, and certain knowledge of the system. In particular, the ``minimal controllers'' require knowledge of the values $P(i\gw_k)$ of the transfer function $P(\gl)=\CL R(\gl,A)B+D$ of the system at the complex frequencies $\set{i\gw_k}_k\subset i\R$ of the reference and disturbance signals~\eqref{eq:yrefwdist}.
The other controller structures also use knowledge of the parameters $(A,B,C,D)$ of the system as they involve designing an observer for~\eqref{eq:plantintro}, and require stabilizing feedback and output injection operators. See Section~\ref{sec:ControllerTypes} for more information on the controller-specific requirements.

\section{Using the Software}

The \texttt{rorpack} Python library can be installed for Python 2 or Python 3 as instructed in the \texttt{README.md} file included in the software package (this mainly involves downloading the source codes and typing '\texttt{pip install .}' or '\texttt{pip3 install .}' in the main directory). The subdirectory \texttt{examples/} contains the included PDE examples and simulation files (documented in detail in Section~\ref{sec:PDEcases}).

The following commented example file explains the typical structure and workflow of the controller construction and simulation with \RORname. The considered example is case included in the file \texttt{heat\_1d\_3.py} and documented in Section~\ref{sec:Heat1D3}. Due to the properties of the Python language, the constructor routines used in the main simulation are written at the \textit{beginning}  of the file.

Contents of the file \texttt{heat\_1d\_3.py}: The file begins with comment lines and loading of the necessary parts of the \texttt{rorpack} library as well as other Python packages.

\begin{lstlisting}
'''
Heat equation on the interval [0,1] with  Neumann boundary control
and Dirichlet boundary observation. Approximation with a Finite 
Difference scheme.

Neumann boundary disturbance at x=0, two distributed controls and
two distributed measurements regulated outputs. The controls act 
on the intervals 'IB1' and 'IB2' (Default 'IB1' = [0.3,0.4] and 
'IB2' = [0.6,0.7]) and the measurements are the average 
temperatures on the intervals 'IC1'  and 'IC2' (Default 
'IC1' = [0.1,0.2] and 'IC2' = [0.8,0.9]).
'''
import numpy as np
from rorpack.system import LinearSystem
from rorpack.controller import *
from rorpack.closed_loop_system import ClosedLoopSystem
from rorpack.plotting import *
from laplacian import diffusion_op_1d
\end{lstlisting}

The next part introduces a constructor routine to define the Finite Difference approximation of the heat equation and the input and output operators. The parameter $N$ is the size of the approximation and \texttt{cfun} is a function describing the spatially varying thermal diffusivity of the material.

\begin{lstlisting}
def construct_heat_1d_3(N, cfun, IB1, IB2, IC1, IC2):
    spgrid = np.linspace(0, 1, N+1)

    plt.plot(spgrid,cfun(spgrid))
    plt.title('The thermal diffusivity $c(x)$ of the material')
    plt.tight_layout()
    plt.grid(True)
    plt.show()

    h = spgrid[1]-spgrid[0]
    DiffOp, spgrid = diffusion_op_1d(spgrid, cfun, 'ND')
    A = DiffOp

    B1 = 1/(IB1[1] - IB1[0])*np.logical_and(spgrid >= IB1[0], 
            spgrid <= IB1[1])
    B2 = 1/(IB2[1] - IB2[0])*np.logical_and(spgrid >= IB2[0],
            spgrid <= IB2[1])
    B = np.stack((B1, B2), axis=1)
    C1 = h/(IC1[1] - IC1[0])*np.logical_and(spgrid >= IC1[0],
            spgrid <= IC1[1])
    C2 = h/(IC2[1] - IC2[0])*np.logical_and(spgrid >= IC2[0],
            spgrid <= IC2[1])
    C = np.stack((C1, C2))
    D = np.zeros((2, 2))
    Bd = np.bmat([[np.atleast_2d(-2/h)], [np.zeros((N-1, 1))]])

    return LinearSystem(A, B, C, D, Bd, np.zeros((2,1))), spgrid
 \end{lstlisting}

 The next part defines the parameters of the system and constructs the system $(A,B,B_d,C,D)$ as an object of the class \texttt{LinearSystem} of \RORname.

\begin{lstlisting}
# Parameters for this example.
N = 100

# The spatially varying thermal diffusivity of the material
# cfun = lambda x: np.ones(np.atleast_1d(x).shape)
# cfun = lambda x: 1+x
# cfun = lambda x: 1-2*x*(1-2*x)
cfun = lambda x: 1+.5*np.cos(5/2*np.pi*x)
# Note: Lower diffusivity is difficult for the Low-Gain
# and Passive controllers
# cfun = lambda x: .2-.4*x*(1-x)

# Regions of inputs and outputs
IB1 = np.array([0.3, 0.4])
IB2 = np.array([0.6, 0.7])
IC1 = np.array([0.1, 0.2])
IC2 = np.array([0.8, 0.9])

# Length of the simulation
t_begin = 0
t_end = 8
t_points = 300

# Construct the system.
sys, spgrid = construct_heat_1d_3(N, cfun, IB1, IB2, IC1, IC2)
  \end{lstlisting}

The next part defines the reference signal $\yref(t)$ (in \texttt{yref}) and the disturbance signal $\wdist(t)$ (in \texttt{wdist}) and lists the (real) frequencies $\set{\gw_k}_{k=1}^q$ in the variable \texttt{freqsReal}. Alternative reference and disturbance signals are commented out in the code for further simulation experiments.

\begin{lstlisting}
# Define the reference and disturbance signals, and list the
# required frequencies in 'freqsReal'
# Case 1:
yref = lambda t: np.stack((np.sin(2*t), 2*np.cos(3*t)))
wdist = lambda t: np.sin(6*t)

# Case 2:
# yref = lambda t: np.ones((2,np.atleast_1d(t).shape[0]))
# wdist = lambda t: np.zeros(np.atleast_1d(t).shape)

freqsReal = np.array([0, 1, 2, 3, 6])
\end{lstlisting}

The next part constructs the chosen controller structure and the closed-loop system as objects of the \RORname\ classes. Alternative controller structures are commented out in the code for easy comparison of controller performances.

\begin{lstlisting} 
# Construct the controller and the closed loop system.

# Controller choices, Low-gain robust controller
# Requires the transfer function values P(i*w_k)
# epsgainrange = np.array([0.3,0.6])
# Pvals = np.array(list(map(sys.P, 1j * freqsReal)))
# contr = LowGainRC(sys, freqsReal, epsgainrange, Pvals)


# Dual observer-based controller
# Requires stabilizing operators K and L1
# and the transfer function values P_L(i*w_k)
# K = -sys.B.conj().T
# L1 = -10*sys.C.conj().T
# PLvals = np.array(list(map(lambda freq: sys.P_L(freq, L1),
#     1j * freqsReal)))
# IMstabmargin = 0.5
# IMstabmethod = 'LQR'
# contr = DualObserverBasedRC(sys, freqsReal, PLvals, K, L1, 
#	IMstabmargin, IMstabmethod)

# Observer-based controller
# Requires stabilizing operators K21 and L
# and the transfer function values P_K(i*w_k)
K21 = -sys.B.conj().T
L = -10*sys.C.conj().T
PKvals = np.array(list(map(lambda freq: sys.P_K(freq, K21), 
    1j * freqsReal)))
IMstabmargin = 0.5
IMstabmethod = 'LQR'
contr = ObserverBasedRC(sys, freqsReal, PKvals, K21, L,
	IMstabmargin, IMstabmethod)

# Construct the closed-loop system 
clsys = ClosedLoopSystem(sys, contr) 
\end{lstlisting}

The next part simulates the system behaviour of the closed-loop system. The initial state of the system is chosen in the variable \texttt{x0}, and the initial state of the controller is chosen by default to be zero.

\begin{lstlisting}
# Simulate the system, define the initial state x_0
# x0fun = lambda x: np.zeros(np.size(x))
x0fun = lambda x: 0.5 * (1 + np.cos(np.pi * (1 - x)))
# x0fun = lambda x: 3*(1-x)+x
# x0fun = lambda x: 1/2*x**2*(3-2*x)-1
# x0fun = lambda x: 1/2*x**2*(3-2*x)-0.5
# x0fun = lambda x: 1*(1-x)**2*(3-2*(1-x))-1
# x0fun = lambda x: 0.5*(1-x)**2*(3-2*(1-x))-0.5
# x0fun = lambda x: 0.25*(x**3-1.5*x**2)-0.25
# x0fun = lambda x: 0.2*x**2*(3-2*x)-0.5
x0 = x0fun(spgrid)

# z0 is chosen to be zero by default
z0 = np.zeros(contr.G1.shape[0])
xe0 = np.concatenate((x0, z0))

tgrid = np.linspace(t_begin, t_end, t_points)
sol,output,error,control,t = clsys.simulate(xe0,tgrid, yref, wdist)
print('Simulation took %f seconds' % t)
\end{lstlisting}

Finally, the results of the simulation are plotted in separate figures and the behaviour of the controlled state is animated using the user-defined routines.

\begin{lstlisting}
# Plot the output and the error, and animate the behaviour 
# of the controlled state.
plot_output(tgrid, output, yref, 'subplot', 'default')
plot_error_norm(tgrid, error)
plot_control(tgrid, control)

# In plotting and animating the state, fill in the homogeneous
# Dirichlet boundary condition at x=1
sys_state = np.vstack((sol.y[0:N],np.zeros((1,np.size(tgrid)))))
spgrid = np.concatenate((spgrid,np.atleast_1d(1)))

plot_1d_surface(tgrid, spgrid, sys_state, colormap=cm.plasma)
animate_1d_results(spgrid, sys_state, tgrid)
\end{lstlisting}


\section{Implemented Controller Types}
\label{sec:ControllerTypes}

In this section we list the concrete controllers implemented in \RORname.
The documentation of the code includes additional information on the usage of the construction routines.
The controllers are the following:
\begin{itemize}
  \item The ``minimal robust controller'' (including only the internal model), based on references~\cite{HamPoh00},~\citel{Pau16a}{Sec. IV}. Stabilization of the closed-loop system is based on selection of a suitable \keyterm{low-gain parameter} $\eps>0$.\\[1ex]
      Calling sequence for the construction:\\[-1ex]
     \begin{quotation}
       \texttt{LowGainRC(sys,freqsReal,epsgain,Pvals)}
     \end{quotation}
     \medskip
     where \texttt{sys} contains the parameters of the plant, \texttt{freqs} contains the frequencies $\set{\gw_k}_{k=0}^q$ of the signals $\yref(t)$ and $\wdist(t)$ in~\eqref{eq:yrefwdist}, \texttt{epsgain} is the value of the low-gain parameter $\eps>0$. Finally, \texttt{Pvals} is a $(q+1)\times p\times m$ array containing the values $P(i\gw_k)=\CL R(i\gw_k,A)B+D\in \C^{p\times m}$ of the transfer function of~\eqref{eq:plantintro} at the complex frequencies $\set{i\gw_k}_{k=0}^q$ of the reference and disturbance signals in~\eqref{eq:yrefwdist}.
     The parameter \texttt{epsgain} can alternatively be a vector of length 2 providing minimal and maximal values for $\eps$. The controller construction has a naive functionality for finding an $\eps$ to optimize stability margin of the numerically approximated closed-loop system (simply by starting from the minimal value and increasing $\eps$ in steps). 

     \bigskip

  \item The ``observer-based robust controller'', based on references~\citel{HamPoh10}{Sec. 7},~\citel{Pau16a}{Sec. VI},~\citel{Pau17b}{Sec. 5}. The closed-loop stability is achieved using an observer for the state of the system~\eqref{eq:plantintro}.\\[1ex]
      Calling sequence for the construction:\\[-1ex]
     \begin{quotation}
       \texttt{ObserverBasedRC(sys,freqsReal,K21,L,\\ 
	 \phantom{a}\hspace{2.7cm} IMstabmargin,IMstabmethod,CKRKvals)}
     \end{quotation}
     \medskip
     where \texttt{sys} contains the parameters of the plant, \texttt{freqsReal} contains the frequencies $\set{\gw_k}_{k=0}^q$ of the signals $\yref(t)$ and $\wdist(t)$ in~\eqref{eq:yrefwdist}.
     The parameters \texttt{K21} and \texttt{L} describe operators $K_{21}$ and $L$, respectively, such that $A+BK_{21}^\Lambda$ and $A+L\CL$ generate exponentially stable semigroups. 

     Instead of the approach used in~\cite{Pau16a}, the ``internal model'', i.e., the pair $(G_1,B_1)$, in the controller is stabilized using either LQR-based design (\texttt{IMstabmethod = 'LQR'}, by default) or pole placement (\texttt{IMstabmethod = 'poleplacement'}) with a stability margin \texttt{IMstabmargin} (default = \texttt{0.5}). Note that the variable \texttt{IMstabmargin} only determines the stability margin of the internal model, and the stability margin of the closed-loop system also depends on the stability margins of the semigroups generated by $A+BK_2^\Lambda$ and $A+L\CL$.
     Finally, \texttt{CKRKvals} (optional) is a $(q+1)\times p\times N$ array containing elements $(\CL +DK_{21}^\Lambda)R(i\gw_k,A+BK_{21}^\Lambda)\in \C^{p\times N}$ for $k=\List[0]{q}$. If this parameter is not given, the routine computes these values based on the same numerical approximation as the one used in the simulation.
  \item The ``dual observer-based robust controller'', based on references~\citel{Pau16a}{Sec. V},~\citel{Pau17b}{Sec. 4}. The closed-loop stability is achieved using a complementary controller structure that coincides with observer-based stabilization of the dual of the closed-loop system.\\[1ex]
      Calling sequence for the construction:\\[-1ex]
     \begin{quotation}
       \texttt{DualObserverBasedRC(sys,freqsReal,K2,L1,\\
	 \phantom{a}\hspace{2.7cm} IMstabmargin,IMstabmethod,RLBLvals)}
     \end{quotation}
     \medskip
     where \texttt{sys} contains the parameters of the plant, \texttt{freqs} contains the frequencies $\set{\gw_k}_{k=0}^q$ of the signals $\yref(t)$ and $\wdist(t)$ in~\eqref{eq:yrefwdist}. The parameters \texttt{K2} and \texttt{L1} describe operators $K_2$ and $L_1$, respectively, such that $A+BK_2^\Lambda$ and $A+L_1\CL$ generate exponentially stable semigroups. 

     Instead of the approach in~\cite{Pau16a}, the ``internal model'', i.e., the pair $(C_1,G_1)$, in the controller is stabilized using either LQR-based design (\texttt{IMstabmethod = 'LQR'}) or pole placement (\texttt{IMstabmethod = 'poleplacement'}) with a predefined stability margin \texttt{IMstabmargin}. Note that the variable \texttt{IMstabmargin} only determines the stability margin of the internal model, and the stability margin of the closed-loop system also depends on the stability margins of the semigroups generated by $A+BK_2^\Lambda$ and $A+L_1\CL$.

     Finally, \texttt{RLBLvals} (optional) is a $(q+1)\times N\times m$ array containing elements $R(i\gw_k,A+L_1\CL)(B+L_1D)\in \C^{N\times m}$ for $k=\List[0]{q}$. If this parameter is not given, the routine computes these values based on the same numerical approximation as the one used in the simulation.


  \item The ``passive minimal controller'' based on~\citel{RebWei03}{Thm. 1.2},~\citel{Pau17carxiv}{Sec. 5.1},~\cite{PauLeGLHMNC18}. The closed-loop stability is achieved using passive controller design and a \keyterm{power preserving interconnection} between the passive systems.\\[1ex]
      Calling sequence for the construction:\\[-1ex]
     \begin{quotation}
	 \texttt{PassiveRC(freqsReal,dim\_Y,epsgain,sys,Dc)}
     \end{quotation}
     \medskip
     where
     \texttt{freqsReal} contains the (real) frequencies $\set{\gw_k}_{k=0}^q$ of the signals $\yref(t)$ and $\wdist(t)$ in~\eqref{eq:yrefwdist}, \texttt{dim\_Y} is the dimension of the output space, \texttt{epsgain} is a parameter $\eps>0$ which controls the norm of $G_2$ and $K$,
     and \texttt{sys} contains the parameters of the plant. The parameter \texttt{Dc} is the controller feedthrough matrix which can be used as a ``prestabilizing'' output feedback to the system (a negative definite \texttt{Dc} corresponds to prestabilizing negative output feedback to the system). 
     In addition, \texttt{Pvals} is a $(q+1)\times p\times m$ array containing the values $P(i\gw_k)=\CL R(i\gw_k,A)B+D\in \C^{p\times m}$ of the transfer function of~\eqref{eq:plantintro} at the complex frequencies $\set{i\gw_k}_{k=0}^q$ of the reference and disturbance signals in~\eqref{eq:yrefwdist}. The parameter \texttt{Pvals} is optional and it is currently not used in the controller design.
     In future versions of the implementation this information may be used to improve the performance of the controller.

The parameter \texttt{epsgain} can alternatively be a vector of length 2 providing minimal and maximal values for $\eps$. The controller construction has a naive functionality for finding an $\eps$ to optimize stability margin of the numerically approximated closed-loop system (simply by starting from the minimal value and increasing $\eps$ in steps). 



     \COMMapproxRC{
     \item An ``approximate robust controller'' based on the reference~\cite{HumKur18} for finite-dimensional approximate control design for systems with infinite-dimensional output spaces.\\[1ex]
	 Calling sequence for the construction:\\[-1ex]
	   \begin{quotation}
	     \texttt{ApproximateRC(\dots)}
	   \end{quotation}
	 }
%  \item TODO: Implement Galerkin-ROM controllers for parabolic systems.
\end{itemize}

\subsection{Comments on the Controller Parameters}

In this section we make some remarks on the choices of the controller parameters.

\textbf{The gain parameter $\eps>0$ in }\texttt{LowGainRC}. 
The theory in~\cite{HamPoh00,RebWei03} guarantees that for a stable system $(A,B,C,D)$ there exists $\eps^\ast>0$ such that for any $0<\eps<\eps^\ast$ the closed-loop system is exponentially stable. The stability margin of the closed-loop system (which directly determines the convergence rate of the regulation error $e(t)$) can be optimized with a suitable choice of $\eps>0$. Finding such an optimal value of $\eps>0$ for a PDE system is a challenging task, but in numerical simulations one can use a naive approach of tracking the spectrum of the finite-dimensional closed-loop system matrix $A_e(\eps)$. This is the approach taken in the example cases in \RORname, though it should be noted that for general PDE systems there is no guarantee that the value $\eps>0$ obtained this way would optimize the closed-loop system for the original PDE system. 
In the example cases we are mainly interested in finding an $\eps>0$ which achieves a reasonable rate of convergence rate of the error $\norm{e(t)}$.

The gain in the passive robust controller \texttt{PassiveRC} can analogously be adjusted with a choice of a parameter $\eps>0$ to optimize the closed-loop stability margin.

\textbf{The transfer function values.} The controllers make use of the values $P(i\gw_k)$, $P_K(i\gw_k)$ and $P_L(i\gw_k)$ of the transfer functions associated to the original or stabilized versions of the PDE system.
The \RORname\ class \texttt{LinearSystem} has the necessary routines for computing these values based on the matrices \texttt{A}, \texttt{B}, \texttt{C}, and \texttt{D}. However, using the same approximation of the PDE for both controller design and simulation corresponds to essentially controlling the approximation as a finite-dimensional system. If possible, to avoid unrealistically positive results, it is therefore better to use two different approximations for controller construction and simulation. This is especially the case if the validity of the approximation for the computation of the parameters can not be guaranteed with absolute certainty. However, there are of course cases, such as parabolic systems with the Galerkin approximations~\cite{Mor94}, where the values of the controller parameters can be shown to converge with the order of the approximation, and above concerns are unnecessary.
The same comments apply to the parameters \texttt{CKRKvals} and \texttt{RLBLvals}.

For some special PDEs, such as 1D heat or wave equations with constant coefficients, the values $P(i\gw_k)$ may have explicit expressions, but these are very limited special cases. For PDEs with spatially varying parameters there are powerful computational methods that can be used to determine $P(i\gw_k)$, such as the \textbf{Chebfun} package (\href{https://chebfun.org/}{https://chebfun.org/}) employed in \texttt{heat\_1d\_2.py} in Section~\ref{sec:Heat1D2} (``Case 2'').



\section{PDE Models of the Example Cases}
\label{sec:PDEcases}

In this section we introduce the PDE models considered in the example cases and review their fundamental properties.

The considered reference and disturbance signals are in each case combinations of trigonometric functions of the form~\eqref{eq:yrefwdist} with a given set of frequencies. The precise choices of the signals can be seen from the main files of the examples. Similarly, the chosen initial states are visible from the source files, and in several files alternative initial states are provided (these can be used by uncommenting the corresponding lines).

\subsection{The 1D Heat Equations}

This collection of examples consider 1D heat equations with spatially varying thermal diffusivity on $\Omega = [0,1]$ with different configurations of control inputs and measured outputs. The first two cases consider control, disturbance, and observation on the boundary, and the final example considers a system with two distributed inputs and outputs. In general, any combination of the above types of inputs and outputs is possible. 
The main property from the point of view of robust output regulation is whether or not the uncontrolled system is exponentially stable (minimal low-gain controller can be used) or passive (the passive robust controller can be used).

In each of the cases, the semidiscretization of the PDE is completed using Finite Differences.

\subsubsection*{Case 1: Neumann boundary input at $\xi = 0$, disturbance and output at $\xi = 1$}
~\\[-1ex]

  \noindent Main file name: \texttt{heat\_1d\_1.py}

\medskip

The model on $\Omega = [0,1]$ is
\eq{
  \pd{x}{t}(\xi,t) &=  \pdb{\xi}(c(\xi)\pd{x}{\xi})(\xi,t), \qquad x(\xi,0)=x_0(\xi) \\
      -\pd{x}{\xi}(0,t) &= u(t), \qquad 
      \pd{x}{\xi}(1,t) = \wdist(t), \\
      y(t) &= x(1,t),
    }
    where $c(\cdot)\geq c_0>0$ is the spatially varying \textit{thermal diffusivity} of the material.
    The uncontrolled system is unstable due to the eigenvalue $\gl=0$. 
%    Since the control input $u(t)$ and output $y(t)$ are not collocated, the system can not be 
The example uses the ``Observer-Based Robust Controller'' and ``Dual Observer-Based Robust Controller'' to achieve robust output tracking and disturbance rejection.

\subsubsection*{Case 2: Input, output, and disturbance at $\xi = 0$, Dirichlet at $\xi = 1$}
\label{sec:Heat1D2}
~\\[-1ex]

  \noindent Main file name: \texttt{heat\_1d\_2.py}

\medskip

The model on $\Omega = [0,1]$ is
\eq{
  \pd{x}{t}(\xi,t) &=  \pdb{\xi}(c(\xi)\pd{x}{\xi})(\xi,t), \qquad x(\xi,0)=x_0(\xi) \\
      -\pd{x}{\xi}(0,t) &= u(t)+\wdist(t), \qquad 
      x(1,t) = 0, \\
      y(t) &= x(0,t),
    }
    where $c(\cdot)\geq c_0>0$ is the spatially varying thermal diffusivity of the material.
The uncontrolled system is exponentially stable due to the homogeneous Dirichlet boundary condition at $\xi = 1$. The system is also impedance passive since the control input and measured output are collocated,  and because of this the robust output regulation problem can be solved using the Passive Robust Controller.
%    Since the control input $u(t)$ and output $y(t)$ are not collocated, the system can not be 

Here we use the \textbf{\mbox{Chebfun} package}~\cite{DriHal14book,Tre13book} (\href{https://chebfun.org/}{https://chebfun.org/}) in computing the values $P(i\gw_k)$ of the transfer function as well as other parameters required in the controller construction. The Chebfun package utilizes spectral methods and provides powerful and easy-to-use tools for the solution of (especially 1D) boundary value problems with accuracies close to machine precision.
Because of this, Chebfun has great potential in controller design for PDEs and it is especially perfectly suited for robust output regulation of this class of systems.
The only drawback from \RORname's perspective is that at the moment Chebfun is only implemented in Matlab\footnote{Though partial Python implementations exist, the most important functionality for solving BVPs can only be found in the original Matlab version.}. However, using the Python-to-Matlab interface library ``\texttt{matlab.engine}'' included in Matlab (since R2014b), it is possible to call Matlab scripts and functions directly from Python. This approach is used by default in the current PDE example case (this requires installed versions of Matlab, Chebfun package, and the separate installation \texttt{matlab.engine} Python package, see \href{https://se.mathworks.com/help/matlab/matlab-engine-for-python.html}{https://se.mathworks.com/help/matlab/matlab-engine-for-python.html} for details). 
The downside of this approach is that the startup time of the Matlab engine in Python can be extremely slow, and therefore the computations require a relatively long time. However, we get the benefit of very accurate values of the controlled PDE system to be used in the controller design.

Alternate computations of the controller parameters using the Finite Difference approximation (the one used in the main simulation) are commented out in the example code, and can be uncommented to run the \texttt{heat\_1d\_2} example case without the Matlab interface.


\subsubsection*{Case 3: Distributed input and output, boundary disturbance at $\xi = 0$, Dirichlet at $\xi = 1$}
\label{sec:Heat1D3}
~\\[-1ex]

  \noindent Main file name: \texttt{heat\_1d\_3.py}

\medskip

The model on $\Omega = [0,1]$ is
\eq{
  \pd{x}{t}(\xi,t) &=  \pdb{\xi}(c(\xi)\pd{x}{\xi})(\xi,t)+b_1(\xi)u_1(t) + b_2(\xi)u_2(t)  \\
      -\pd{x}{\xi}(0,t) &= \wdist(t), \qquad 
      x(1,t) = 0,  \quad x(\xi,0)=x_0(\xi),\\
      y(t) &= \int_0^1\pmat{c_1(\xi)x(\xi,t)\\c_2(\xi)x(\xi,t)}d\xi\in \R^2
    }
    where $c(\cdot)\geq c_0>0$ is the spatially varying thermal diffusivity of the material and
%    $b_1(\xi)=10\chi_{[.3,.6]}(\xi)$ and $b_2(\xi)=10\chi_{[.6,.7]}(\xi)$ and 
\eq{
  b_1(\xi)&=10\chi_{[.3,.6]}(\xi) , \quad
   b_2(\xi)=10\chi_{[.6,.7]}(\xi), \\
  c_1(\xi)&=10\chi_{[.1,.2]}(\xi), \quad c_2(\xi)=10\chi_{[.8,.9]}(\xi) .
}
    Here $\chi_{[a,b]}(\cdot)$ is the characteristic function on the interval $[a,b]\subset [0,1]$, and thus the control inputs act on the intervals $[0.3,0.4]$ and $[0.6,0.7]$, and the outputs measure the average temperatures on the intervals $[0.1,0.2]$ and $[0.8,0.9]$.
The uncontrolled system is stable because of the homogeneous Dirichlet boundary condition at $\xi = 1$. 

Figure~\ref{fig:1Dheat3} shows example results of the simulations including plots of the outputs and reference signals, norm of the regulation error, computed control signals, and the state of the controlled system as a function of $\xi$ and $t$.

\begin{figure}[h!]
  \begin{minipage}{0.48\linewidth}
    \includegraphics[width=\linewidth]{H1d3out.png}

    \vspace{2ex}

    \includegraphics[width=\linewidth]{H1d3err.png}
  \end{minipage}
  \hfill
  \begin{minipage}{0.48\linewidth}
    \includegraphics[width=.95\linewidth]{H1d3surf.png}

    \vspace{2ex}

    \begin{center}
      \includegraphics[width=0.93\linewidth]{H1d3control.png}
    \end{center}
  \end{minipage}
%  \includegraphics{}
\caption{Example output of the 1D Heat equation (``Case 3'').}
  \label{fig:1Dheat3}
\end{figure}

%The examples consider one-dimensional boundary controlled heat equations on $\Omega = [0,1]$
%  \begin{subequations}
%    \label{eq:heatex1D}
%    \eqn{
%      x_t(\xi,t) &=  x_{\xi\xi}(\xi,t), \qquad x(\xi,0)=x_0(\xi) \\
%      \pd{x}{n}(\xi,t)\vert_{\Gamma_1} &= u(t), \qquad 
%      \pd{x}{n}(\xi,t)\vert_{\Gamma_2} = \wdist(t), \qquad
%      \pd{x}{n}(\xi,t)\vert_{\Gamma_0} = 0\\
%      y(t) &= \int_{\Gamma_1}x(\xi,t)d\xi.
%    }
%  \end{subequations}
%%  Here the parts $\Gamma_0$, $\Gamma_1$, and $\Gamma_2$ of the boundary $\partial \Omega$ are defined so that
%%  $\Gamma_1 = \setm{\xi=(0,\xi_2)}{0\leq \xi_2\leq 1}$,
%%  $\Gamma_2 = \setm{\xi=(\xi_1,1)}{1/2\leq \xi_1\leq 1}$, 
%%  $\Gamma_0 = \partial \Omega \setminus (\Gamma_1 \cup \Gamma_2)$. By~\cite[Cor. 2]{ByrGil02} the heat equation defines a regular linear system with feedthrough $D=0$. The system is passive,
%%
%Cases:
%\begin{itemize}
%  \item Case 1: $B$ at $x=0$, $B_d$ and $C$ at $x=1$
%  \item Case 2: $B$, $B_d$ and $C$ at $x=0$, Dir at $x=1$
%  \item Case 3: $B_d$ at $x=0$, $B$ and $C$ distributed $2\times 2$
%\end{itemize}
%%IF only one case:
%%$B$ at $x=0$, $B_d$ at $x=1$, $y(t)$ at $x=1$, $y_m$ (if used) at $x=0$.
%%
%%Cases for inputs:
%%\begin{itemize}
%%  \item 1 inputs
%%    \begin{itemize}
%%      \item $B$ at $x=0$ and $x=1$, 
%%    \end{itemize}
%%  \item 1 inputs
%%    \begin{itemize}
%%      \item $B$ at $x=0$ or $x=1$
%%    \end{itemize}
%%\end{itemize}

\subsection{The 2D Heat Equations on Rectangular Domains}

These examples consider two-dimensional heat equations on $\Omega = [0,1]\times [0,1]$ with boundary input and output and boundary disturbances. The inputs and outputs act in an averaged sense on the boundaries.

The reference and disturbance signals are again of the form~\eqref{eq:yrefwdist} and can be seen from the main files of the simulations.

\subsubsection*{Case 1: Collocated input and output}
~\\[-1ex]


  \noindent Main file name: \texttt{heat\_2d\_1.py}

\medskip

This case is considered in~\citel{Pau16a}{Sec. VII}.
The system on $\Omega = [0,1]\times [0,1]$ with two inputs $u(t)=(u_1(t),u_2(t))^T$ and two outputs $y(t)=(y_1(t),y_2(t))^T$ is determined by
%  \begin{subequations}
%    \label{eq:heatex}
    \eq{
      x_t(\xi,t) &= \Delta x(\xi,t), \qquad x(\xi,0)=x_0(\xi) \\
      \pd{x}{n}(\xi,t)\vert_{\Gamma_1} &= u_1(t), \qquad 
      \pd{x}{n}(\xi,t)\vert_{\Gamma_2} = u_2(t), \qquad
      \pd{x}{n}(\xi,t)\vert_{\Gamma_0} = 0\\
      y_1(t) &= \int_{\Gamma_1}x(\xi,t)d\xi, \qquad
      y_2(t) = \int_{\Gamma_2}x(\xi,t)d\xi.
    }
%  \end{subequations}
  Here the parts $\Gamma_0$, $\Gamma_1$, and $\Gamma_2$ of the boundary $\partial \Omega$ are defined so that
  $\Gamma_1 = \setm{\xi=(\xi_1,0)}{0\leq \xi_1\leq 1/2}$,
  $\Gamma_2 = \setm{\xi=(\xi_1,1)}{1/2\leq \xi_1\leq 1}$, 
  $\Gamma_0 = \partial \Omega \setminus (\Gamma_1 \cup \Gamma_2)$. By~\cite[Cor. 2]{ByrGil02} the heat equation defines a regular linear system with feedthrough $D=0$. The system is also impedance passive.
%  \eq{
%    P(\gl) = \frac{\coth(\sqrt{\gl})}{\sqrt{\gl}}, \qquad \gl\in \overline{\C_+}\setminus \set{0},
%  }
%and $\abs{P(i\gw)\inv}=O(\abs{\sqrt{\gw}})$ for $\gw\in\R$ with large $\abs{\gw}$. 
The uncontrolled system is unstable due to the eigenvalue $\gl=0$, but it can be stabilized exponentially with negative output feedback $u(t) = -\kappa y(t)$ for any $\kappa>0$.
In this example we assume the system is pre-stabilized with $\kappa = 1$.

In the simulations, the system is approximated using the eigenmodes of the Laplacian. The system can be controlled either with the low-gain minimal robust controller or the passive controller (with pre-stabilizing negative output feedback), or with one of the observer-based robust controllers.


\subsubsection*{Case 2: Non-collocated input and output}
~\\[-1ex]

  \noindent Main file name: \texttt{heat\_2d\_2.py}

\medskip

A similar case (but with collocated inputs and outputs) was considered in~\citel{Pau17carxiv}{Sec. 6.3}.
The system on $\Omega = [0,1]\times [0,1]$ is
%  \begin{subequations}
%    \label{eq:heatex}
    \eq{
      x_t(\xi,t) &= \Delta x(\xi,t), \qquad x(\xi,0)=x_0(\xi) \\
      \pd{x}{n}(\xi,t)\vert_{\Gamma_1} &= u(t), \qquad 
      \pd{x}{n}(\xi,t)\vert_{\Gamma_3} = \wdist(t), \qquad
      \pd{x}{n}(\xi,t)\vert_{\Gamma_0} = 0\\
      y(t) &= \int_{\Gamma_2}x(\xi,t)d\xi.
    }
%  \end{subequations}
  Here the parts $\Gamma_0$, $\Gamma_1$, $\Gamma_2$, and $\Gamma_3$ of the boundary $\partial \Omega$ are defined so that
  $\Gamma_1 = \setm{\xi=(0,\xi_2)}{0\leq \xi_2\leq 1}$,
  $\Gamma_2 = \setm{\xi=(\xi_1,1)}{0\leq \xi_1\leq 1}$, 
  $\Gamma_3 = \setm{\xi=(\xi_1,0)}{0\leq \xi_1\leq 1/2}$, 
  $\Gamma_0 = \partial \Omega \setminus (\Gamma_1 \cup \Gamma_2\cup \Gamma_3)$. By~\cite[Cor. 2]{ByrGil02} the heat equation defines a regular linear system with feedthrough $D=0$.
The uncontrolled system is unstable due to the eigenvalue $\gl=0$.  

In the simulations, the system is approximated using Finite Differences with a uniform grid. 

\subsection{The 1D Wave Equations}

In these examples we consider  one-dimen\-sional undamped and damped wave equations with control and observation at the boundaries and inside the domain. 

\subsubsection*{Case 1: Non-collocated boundary input and output, disturbance at the output}
~\\[-1ex]

  \noindent Main file name: \texttt{wave\_1d\_1.py}

The model on $\Omega = [0,1]$ is
\eq{
  x_{tt}(\xi,t) &=  x_{\xi\xi}(\xi,t), \qquad x(\xi,0)=x_0(\xi), \quad x_t(\xi,0)=x_1(\xi)\\
      -\pd{x}{\xi}(0,t) &= \wdist(t), \qquad 
      \pd{x}{\xi}(1,t) = u(t), \\
      y(t) &= x_t(0,t), \qquad y_m(t) = \int_0^1 x(\xi,t)dt
    }
    The uncontrolled system is unstable due to the lack of damping. It also cannot be stabilized with output feedback due to the non-collocated configuration of the inputs and outputs.
    The goal is to achieve tracking of the output $y(t)$. The additional measured output $y_m(t)$ is required to achieve closed-loop stability due to the fact that the system is not exponentially detectable with output $y(t)$ (because of the unobservability of the eigenvalue $\gl=0$).

    In the example case, the second output $y_m(t)$ is used to prestabilize eigenvalue $\gl=0$ of the system with preliminary output feedback of the form $u(t)=-\kappa_m y_m(t)+\tilde{u}(t)$ (where $\tilde{u}(t)$ is the new input of the system). There are also other (and better) ways to handle the situation, and these will be implemented in later versions of this example. 
    The pairs $(A,B)$ and $(C,A)$ are stabilized using collocated designs, i.e., we choose $K=-\kappa B^\ast$ and $L=-\ell C^\ast$ to stabilize the pairs $A+BK$ and $A+LC$.
    The main file contains the pre-stabilization gain $K_m>0$ and the gains $\kappa,\ell>0$ as design parameters.

    The example considers output tracking of the velocity $x_t(0,t)$ to arbitrary 2-periodic reference signals. This is achieved by including  frequencies of the form $k\pi$ for $k\in \List{q}$ in the internal model.  The reference signal is defined by defining its profile over one period in the  variable '\texttt{yref1per}'. Note that it is not necessary to compute the amplitudes of the frequency components of $\yref(t)$ (which would be equivalent to finding the Fourier series  expansion of the reference signal).

In the simulations the system is approximated using the orthonormal eigenfunctions of the undamped wave operator.
Figure~\ref{fig:1Dwave1} shows example results of the simulation for two different periodic reference signals --- a nonsmooth triangle signal and signal consisting of semicircles.


%\subsubsection*{Example output}
%
%Figure~\ref{fig:1Dwave1} shows example output with the following parameters:  
%\begin{itemize}
%  \item Controller: Observer-based robust controller, 'LQR' stabilization with stability margin $=1$
%  \item System stabilization: $\kappa_m = .3$, $\kappa=.9$, $\ell = .8$.
%  \item Signals: $\yref(t) = -2\cos(\pi t/2)+\sin(\pi t/2)$, $\wdist(t) = \sin(4\pi t)$ (frequencies $\set{\gw_k}_k=\set{\pi/2,\pi,2\pi,3\pi,4\pi}$), 
%  \item Initial state: $x_0(\xi)=30\xi^2(1-\xi)^2-1$, $x_1(\xi)\equiv 0$, controller initial state $=0$
%\end{itemize}

\begin{figure}[h!]
  \centering
  \begin{minipage}{0.48\linewidth}
    \begin{flushleft}
      \includegraphics[width=\linewidth]{W1dout_triangle.png}
    \end{flushleft}
  \end{minipage}
  \begin{minipage}{0.48\linewidth}
    \begin{flushright}
      \includegraphics[width=\linewidth]{W1dout_semic.png}
    \end{flushright}
  \end{minipage}

  \vspace{3ex}

    \begin{center}
      \includegraphics[width=.95\linewidth]{W1dprofile_triangle.png}
    \end{center}
    \caption{Example outputs of the periodic tracking for the 1D wave equation (``Case 1'').}
  \label{fig:1Dwave1}
\end{figure}

%\begin{itemize}
%  \item Boundary damping, exponentially stable system, spectral approximation.
%\end{itemize}

\subsubsection*{Case 2: Collocated distributed input and output}
~\\[-1ex]

  \noindent Main file name: \texttt{wave\_1d\_2.py}

The model on $\Omega = [0,1]$ is
\eq{
  x_{tt}(\xi,t) &=  x_{\xi\xi}(\xi,t) + b(\xi)u(t) + b_d(\xi)\wdist(t)\\
      x(0,t) &= 0, \qquad 
      x(1,t) = 0 \\
x(\xi,0)&=x_0(\xi), \quad x_t(\xi,0)=x_1(\xi)\\
      y(t) &=  \int_0^1 b(\xi)x(\xi,t)dt
    }
    for some $b(\cdot),b_d(\cdot)\in \Lp[2](0,1;\R)$.
    The uncontrolled system is unstable due to the lack of damping. Since the input and output are distributed, it is not exponentially stabilizable or detectable, but instead it is only strongly (or polynomially~\cite{BorTom10}) stabilizable provided that $\iprod{b(\cdot)}{\sin(k\pi \cdot)}_{\Lp[2]}\neq 0$ for all $k\in\N$.
    Because of this, it is not possible to use the low-gain controller, and the two observer-based controller designs are not guaranteed to achieve closed-loop stability. However, since the system is impedance passive, the Passive Robust Controller can be used in achieving robust output regulation even in the absence of exponential stability as shown in~\citel{Pau17carxiv}{Sec. 5.1}.
Due to the sub-exponential closed-loop stability, the regulation error does not converge with any uniform convergence rate, but instead the rate depends on the initial state of the system. 

In the simulations the system is approximated using the orthonormal eigenfunctions of the undamped wave operator.


\COMMapproxRC{
  \subsection{The 2D Wave Equation on an Annulus}

  The boundary controlled 2D wave equation we consider is of the form as in~\cite{HumKur18}. In particular, 
  $\Omega\subset\R^n$ is a bounded domain (an open connected set) with a Lipschitz-continuous boundary $\partial\Omega$ split into two parts $\Gamma_0,\Gamma_1$ such that $\overline{\Gamma_0}\cup\overline{\Gamma_1}=\partial\Omega$, $\Gamma_0\cap\Gamma_1=\emptyset$, and $\partial\Gamma_0,\partial\Gamma_1$ both have surface measure zero. The wave equation is of the form
  %\begin{equation}\label{eq:waveintro}
  %  \left\{
  %    \begin{aligned}
  \eq{
    \rho(\zeta)\frac{\partial^2 w}{\partial t^2} (\zeta,t) &= \nabla\cdot \big(T(\zeta)\,\nabla w\,(\zeta,t)\big), \quad \zeta\in\Omega,\\
    u (\zeta,t) &= \nu\cdot T(\zeta)\,\nabla w(\zeta,t), \quad \zeta\in\Gamma_1,\\
    y (\zeta,t) &= \frac{\partial w}{\partial t}(\zeta,t), \qquad \zeta\in\Gamma_1,\\
    0 &= \frac{\partial w}{\partial t}(\zeta,t),\qquad \zeta\in\Gamma_0,~t>0 \\
    z(\cdot,0) &= w_0,\qquad \frac{\partial z}{\partial t}(\cdot,0)=w_1,
    %\end{aligned}\right.
  }
  %\end{equation}
  where $w(\zeta,t)$ is the displacement from the equilibrium at the point $\zeta\in\Omega$ and time $t\geq0$, $\rho(\cdot)$ is the mass density, $T^*(\cdot)=T(\cdot)\in L^2(\Omega;\R^n)$ is Young's modulus and $\nu\in L^\infty(\partial\Omega;\R^n)$ is the unit outward normal at $\partial\Omega$. The functions $\rho(\cdot)$ and $T(\cdot)$ are essentially bounded from both above and below away from zero. In the equation, the boundary input and boundary measurement are collocated.

  In particular, we consider the wave equation on an annulus 
  $\Omega := \set{\zeta \in \mathbb{R}^2 \mid 1 < \|\zeta\| < 2}$. 
  We choose $\partial \Omega = \Gamma_0 \cup \Gamma_1$ where $\Gamma_0 = \set{\zeta \in \partial\Omega \mid \|\zeta\| = 1}$ and $\Gamma_1 = \set{\zeta \in \partial\Omega \mid \|\zeta\| = 2}$ so that the control and the measurement are on the outer boundary of the annulus.

  The output space is infinite-dimensional,  $Y :=  \setm{h\in H^{1/2}(\partial\Omega)}{ h\vert_{\Gamma_0}=0}$ which is continuously and densely embedded into $L^2(\Gamma_1)$~\citel{TucWei09book}{Thm.~13.6.10}. 
  The \keyterm{approximate robust controller} is designed based on finite-dimensional Fourier subspaces
  %\eq{
  %  Y_N := \operatorname{span}\left(e^{ik\cdot}\right)_{k=-N}^N
  %}
  of $Y$, and the corresponding orthonormal projection $P_N$ onto $Y_N$.
  %
  %as the sequence $\displaystyle \left(\frac{1}{\sqrt{2\pi}}e^{ik\cdot}\right)$ is an orthonormal basis of $L^2([-\pi, \pi])$. The projection $P_N$ from $Y$ onto $Y_N$ is then given by
  %\begin{equation}
  %  \label{eq:PN}
  %	P_N y := \frac{1}{2\pi}\sum_{k=-N}^N \left\langle y, e^{ik\cdot} \right\rangle_{L^2([-\pi, \pi])} e^{ik\cdot}.  
  %\end{equation}

  The initial reference and disturbance signals in the example are given by
  \eq{
    y_{ref}(\theta, t)&  = \frac{1}{2\pi^2}(\pi - \theta)^2\sin(\pi t) +
    \frac{1}{2}\sin\left(\frac{\theta}{2}\right)\cos(2\pi t) \\
    w(\theta, t) & = \cos(\theta)\sin(2\pi t) + \sin(\theta)\sin(\pi t).
  }
  The real frequencies are then $\gw_1=\pi$, $ \gw_2=2\pi$.

  The numerical approximation in the example is done using the spectral method based on the eigenvalues and eigenfunctions of the undamped wave equation on the annulus. The approximate controller includes the stabilizing term $D_c$ which corresponds to pre-stabilizing the system with negative output feedback. 
  %The initial choice for the controller is the 
  %The system is passive
}

\subsection{A Controlled Beam Equation}
\label{sec:ControlledBeams}

\medskip

The example is related to the article~\cite{PauLeG22}.
The controlled Timoshenko beam with constant parameters $\rho$ (mass density), $I_\rho$ rotary moment of inertia, $E$  Young's modulus, $I$ moment of inertia, $K$ shear modulus, is given by
\eq{
\rho \pd[2]{w}{t}(\xi,t) &= K \pdb{\xi} \left( \pd{w}{\xi}(\xi,t)-\phi(\xi,t) \right) - d_w \pd{w}{t}(\xi,t)\\
I_\rho \pd[2]{\phi}{t}(\xi,t) &= EI\pd[2]{\phi}{\xi} + K\left( \pd{w}{\xi}(\xi,t)-\phi(\xi,t) \right) \\
& \hspace{3cm}- d_\phi \pd{\phi}{t}(\xi,t) + \chi_{[1-\eta,1]}(\xi)u(t).
}
Here $w(\xi,t)$ is the displacement of the beam at $\xi\in(0,1)$ and $\phi(\xi,t)$ is the rotation angle of the beam. The $d_w$ and $d_\phi$ are viscous damping parameters. 
The control acts through the input profile $\chi_{[1-\eta,1]}(\cdot)$ (the characteristic function of the interval $[1-\eta,1]$ for some $\eta<1$).
The measured output (which is collocated with the control input) is given by
\eq{
y(t) = \int_{1-\eta}^1 \pd{\phi}{t}(\xi,t)dt.
}

In the simulation example the physical parameters of the model are 
\eq{
\rho=1, \quad
 I_\rho = 1, \quad
E=1, \quad
I=1, \quad
K=1, \quad
d_w=2, \quad
d_\phi=2, \quad
\eta = 0.2.
}

In this example, the PDE model is approximated with Finite Differences scheme. This scheme is very simple and easy to implement, but it should be noted that literature offers several more reliable and advanced numerical approximation methods for this class of hyperbolic PDEs, and some of these are able to, for example, preserve the \emph{port--Hamiltonian} structure of the control system.

By default, the control design used in the example is the Passive Robust Controller (\texttt{PassiveRC}), which was also the controller of choice in~\cite{PauLeGLHMNC18}. This controller can be used because the system is both exponentially stable and impedance passive.
Because the control system has bounded input and output operators, it is also possible to use other control design methods, for example the Observer Based Robust Controller (\texttt{ObserverBasedRC}) or the Dual Observer Based Robust Controller (\texttt{DualObserverBasedRC}). The former is implemented and commented out in the code. For these alternative controller designs, the parameters $K_{21}$ and $L$ (the stabilizing state feedback and output injection gain) can be designed using ``collocated design'' as $K_{21} = -\kappa_K B^\ast$ and $L=-\kappa_L C^\ast$ for some gain parameters $\kappa_K,\kappa_L>0$.

Figure~\ref{fig:BeamTim1} shows the outputs of the simulation example.

\begin{figure}[h!]
  \begin{minipage}{0.48\linewidth}
    \begin{flushleft}
      \includegraphics[width=\linewidth]{BTim1output.png}
    \end{flushleft}
  \end{minipage}
  \begin{minipage}{0.48\linewidth}
    \begin{flushright}
      \includegraphics[width=0.95\linewidth]{BTim1profile.png}
    \end{flushright}
  \end{minipage}
    \caption{Example outputs of the controlled Timoshenko beam.}
  \label{fig:BeamTim1}
\end{figure}


\section{Contributors}

%The purpose is to plan a lightweight software package for simulating robust output regulation of (approximated) distributed parameter systems within Matlab.

\begin{description}
  \item[Lassi Paunonen] Project leader, developer (2017--)
  \item[Mikko Aarnos] Developer (2018)
  \item[Jukka-Pekka Humaloja] Developer (2018--)
  \item[Jonne Karru] Developer (2021)
\end{description}


  \appendix

\section{External Links}

\begin{itemize}
  \item \href{https://sysgrouptampere.wordpress.com}{https://sysgrouptampere.wordpress.com} --- Systems Theory Research Group at Tampere University.
  \item \href{http://mathesaurus.sourceforge.net/matlab-numpy.html}{http://mathesaurus.sourceforge.net/matlab-numpy.html} --- Useful information on differences in the Matlab and Python/Numpy syntax for vectors and matrices.
  \item \href{https://chebfun.org}{https://chebfun.org} --- Homepage of the Chebfun Project.
\end{itemize}

\shorten{

  \section{Code: TODO}

  \begin{itemize}
    \item
  \end{itemize}

  TODO [\blue{Later}]
  \begin{itemize}
    \item Integrate the use of \texttt{FEniCS/Dolfin}
    \item Extend construction to systems with complex parameters (need to include values $P(-i\gw_k)$ etc, find a general way to handle both real and complex systems at the same time?
    \item improved color choices for the plots, define ``styles'', e.g., ``temperature'', ``general'', ``deflection''
    \item Youtube Video lecture on usage of RORPack!
  \end{itemize}
}

%Key features:
%\begin{itemize}
%  \item Run from a separate script with specific structure
%  \item Implemented Matlab routines for
%    \begin{itemize}
%      \item Design of controllers (Low-gain, observer-based, observer-dual, simple passive)
%      \item Simulation and plotting of output
%    \end{itemize}
%  \item Platform for defining routines for 
%    \begin{itemize}
%      \item System parameter definitions
%      \item Illustrating the behaviour of solution
%    \end{itemize}
%\end{itemize}
%
%{\color{blue}Note:} If implemented properly, the package could also be used in teaching on the Linear Systems course! (Note to self: Consider changing the name to ``(Introduction to) Mathematical Systems Theory'' to get rid of the overlap in course naming). In this situation the students could build new tutorial examples as course final project works, and these could be published online.
%
%\section{Functionality}
%
%\subsection{From the User's Perspective}
%
%Modular structure of the Robust Controller simulations:
%
%Typical process steps (corresponding to the structure of the control script):
%
%\begin{enumerate}
%%  \item PDE system:
%
%\item Define the PDE system, output $(A,B,B_d,C,D,D_d)$
%
%  \begin{itemize}
%    \item Manual definition, different scenarios, 1D, 2D etc
%    \item Definition from PDE Toolbox data
%    \item Other sources?
%  \end{itemize}
%
%\item Define the reference and disturbance signals, output $\yref(\cdot)$, $\wdist(\cdot)$, and $\set{\gw_k}_k$.
%%  exosystem $(S,E,F)$ and the signals
%
%\item Construct the controller, output $(\mc{G}_1,\mc{G}_2,K)$. Implemented routines for 
%  \begin{itemize}
%    \item Robust low-gain controller
%    \item Observer-based
%    \item Reduced-order controller
%    \item Reduced order IM?
%    \item Approximate regulation?
%  \end{itemize}
%
%    Including: Optimize controller parameters numerically to achieve desirable closed-loop properties? Requires input of the plant parameters. 
%%    Could be seen as part of the controller construction
%
%    Ques: Separate the internal model construction?
%
%  \item Construct the closed-loop system
%
%  \item Simulate the closed-loop system state
%
%  \item Illustrate the output and the error
%
%    \begin{itemize}
%      \item Pointwise plots vs. error integral plots
%    \end{itemize}
%
%  \item Animate the solution of the controlled PDE
%    \begin{itemize}
%      \item Different routines based on the source of the approximation (Manual, PDE Toolbox, other)
%    \end{itemize}
%\end{enumerate}
%
%\subsection{Additional functionality}
%
%Supporting routines
%\begin{itemize}
%  \item Simulation based routine for finding $P(i\gw_k)$ for stable systems
%    \begin{itemize}
%      \item could also be applied for finding $P_K(i\gw_k)$ for other controller structures?
%    \end{itemize}
%\end{itemize}
%
%\section{Implementation}
%
%
%\subsection{Data Structures}
%
%Define a class 'linear system' to be applied for the plant, the controller, and the exosystem.
%
%
%\section{Details on the Routines}
%
%%Controller construction routines:
%
%\subsection{Controller Construction Routines}
%
%\subsubsection{Robust Low-Gain Controller}
%
%    Input data:
%    \begin{itemize}
%      \item IM frequencies
%      \item Output space dimension
%      \item Values $P(i\gw_k)$ 
%      \item Value of the gain $\eps$, vs. range of the gain and $(A,B,C,D)$ for the optimization procedure. What is the best criterion? CL stability margin?
%    \end{itemize}
%
%    Output data:
%    \begin{itemize}
%      \item $(\mc{G}_1,\mc{G}_2,K)$, and $\eps$
%    \end{itemize}
%
%    Comments on the routine:
%    \begin{itemize}
%      \item Optimality concerns for $K$, $\mc{G}_2$? Could add in later revisions when the theory is developed. Or could directly follow HamPoh...
%    \end{itemize}
%
%    Questions: Complex vs real form? Maybe real would be better in any case...
%
%
%    \subsection{System Definition Routines}
%
%%System definition routines:
%
%\subsubsection{General form PDE definition}
%	Most important: general form output data.
%
%    Usage:
%    \begin{itemize}
%      \item \texttt{[sys,x0] = ConstSys2DheatDirBC(...)} with sys.A, sys.B, sys.Bd, sys.C, sys.D
%      \item \texttt{x0 = ConstSys2DheatDirBC(...)}
%    \end{itemize}
%
%    Input data:
%    \begin{itemize}
%      \item PDE parameters
%      \item Initial state as a function handle
%    \end{itemize}
%
%    Output data:
%    \begin{itemize}
%      \item System parameters $(A,B,B_d,C,D,D_d)$
%      \item Initial state
%    \end{itemize}
%
%  Remark: The same function could be used to define only the inital state. 
%
%  Question: Include possibility for a mass matrix?
%
%  \section{Extensions in the Future}
%
%
%  \begin{itemize}
%    \item Possibility to do a version for ORP (without robustness
%      \begin{itemize}
%	\item Main difference: Requires exosystem instead of signals. Or can we represent the theory without the exosystem?
%%	  CL system forms: based on exosystem state vs yref(t) and wdist(t)? Implement both first?
%      \end{itemize}
%    \item Incorporate functionality to create models using the Matlab PDE Toolbox built in routines (define geometry, PDE parameters, input and output operators, FEM approximation)
%  \end{itemize}
%  
%  \section{Plan for 2018}
%
%
%%\bibliographystyle{plain}
%%\bibliography{../reference}
%
%
%\section{A Little Less Important Issues}
%
%\subsection{Name Suggestions}
%
%\begin{itemize}
%  \item RORPack
%  \item ROR(P)Lab
%  \item RORSim
%\end{itemize}



\bibliographystyle{plain}
\bibliography{../../../../../Dropbox/Work/Research/reference}
\end{document}
